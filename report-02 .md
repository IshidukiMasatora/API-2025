
##  API実習　2025　課題レポート（第2回）修正版

  
###  出題範囲：　API実習2025　第4回～第6回まで

###  提出期限：　2025/12/15(月) 17:00

## 出題範囲
- **API実習(4)**：レスポンスデータ設計、JSON/JSONP、フォーマット指定、セキュリティ（XSS, CSRF）、Same-Origin Policy、CORS
- **API実習(5)**：レスポンス項目命名規則、エラー設計、HTTPステータスコード、日付フォーマット、識別子設計
- **API実習(6)**：HTTP仕様、キャッシュ制御、メディアタイプ、コンテンツネゴシエーション、ステータスコード詳細


## 提出形式
- 各問に対して **400～600字程度の解答**を記述
- 図や表を用いる場合はMarkdown記法で挿入



## 課題一覧

### 問1：HTTPステータスコードの分類と役割
HTTPステータスコードは100番台から500番台まで分類されています。それぞれのカテゴリ（情報、成功、リダイレクト、クライアントエラー、サーバエラー）について、**代表的なコードと意味を3つずつ挙げ、API設計でどのような場面で使うか具体例を示してください**。

---
情報（1xx）：例として100 Continue（リクエスト継続）、101 Switching Protocols（プロトコル切替）、102 Processing（処理中）。APIで大規模データ送信時に「続行可能」を示す場面で利用。
成功（2xx）：200 OK（正常成功）、201 Created（新規リソース作成）、204 No Content（成功だが返却データなし）。例えばユーザー登録成功時は201を返す。
リダイレクト（3xx）：301 Moved Permanently（恒久的移動）、302 Found（一時的移動）、304 Not Modified（キャッシュ利用可能）。APIで画像URLが変更された場合に301を返す。
クライアントエラー（4xx）：400 Bad Request（不正リクエスト）、401 Unauthorized（認証失敗）、404 Not Found（リソース不在）。例えば存在しないユーザーIDを指定した場合は404。
サーバエラー（5xx）：500 Internal Server Error（内部障害）、502 Bad Gateway（ゲートウェイ不良）、503 Service Unavailable（サービス停止）。APIサーバが過負荷で応答できない場合に503を返す。 このように適切なコードを返すことで、クライアントは処理結果を正しく理解し、再試行や修正を行える。

### 問2：JSONとXMLの比較
WebAPIのレスポンス形式としてJSONが主流になった理由を、**XMLとの比較で3つ以上挙げて説明してください**。また、**JSONPの仕組みと利用目的、セキュリティ上の問題点を簡潔にまとめてください**。

---
SONがWebAPIレスポンスの主流となった背景には、XMLとの比較で以下の利点がある。
軽量性：JSONはタグ構造がなく、キーと値のペアのみで表現されるためデータ量が少なく、通信効率が高い。
可読性：人間にとって直感的に理解しやすく、JavaScriptとの親和性が高い。XMLは冗長なタグが多く、読みづらい。
パースの容易さ：ブラウザや多くの言語で標準的にJSONパーサが提供され、オブジェクトとして直接扱える。XMLはDOM解析やXPathが必要で処理が複雑。
構造のシンプルさ：階層構造を簡潔に表現でき、API設計に適している。
一方、JSONPはクロスドメイン制約を回避するために考案された仕組みで、scriptタグを利用してJSONを関数呼び出し形式で取得する。利用目的は異なるオリジンからのデータ取得だが、任意のJavaScriptコードが実行されるためXSSの危険があり、セキュリティ上の問題点が大きい。現在はCORSが主流であり、JSONPは推奨されない。

### 問3（実演）：PostmanでSheetDB APIにGETリクエスト
- 無償で利用できるSheetDBの公開エンドポイントを使い、Postmanで`GET`リクエストを送信してください。
- **操作手順**：
  1. Postmanを起動し、新規リクエストを作成
  2. メソッドを`GET`に設定
  3. URLに以下を入力：`https://sheetdb.io/api/v1/58f61be4dda40`
  4. Sendをクリック
- **報告内容**：
  - ステータスコード
   200ok
  - レスポンスヘッダ（`Content-Type`など）
   | キー                      | 値                                                                 |
|---------------------------|--------------------------------------------------------------------|
| Date                      | Mon, 15 Dec 2025 01:58:21 GMT                                      |
| Content-Type              | application/json                                                   |
| Transfer-Encoding         | chunked                                                            |
| Connection                | keep-alive                                                         |
| Server                    | cloudflare                                                         |
| vary                      | Accept-Encoding                                                    |
| Cache-Control             | no-cache, private                                                  |
| x-ratelimit-limit         | 90                                                                 |
| x-ratelimit-remaining     | 89                                                                 |
| access-control-allow-origin | *                                                                 |
| x-frame-options           | SAMEORIGIN                                                         |
| x-xss-protection          | 1; mode=block                                                      |
| x-content-type-options    | nosniff                                                            |
| Content-Encoding          | gzip                                                               |
| cf-cache-status           | DYNAMIC                                                            |
| Nel                       | {"report_to":"cf-nel", "success_fraction...}                       |
| Report-To                 | {"group":"cf-nel", "max_age":604800,"...}                          |
| CF-RAY                    | 9ae255d9ec89612d-NRT                                               |

  - レスポンスJSONのスクリーンショット
![スクリーンショット](images/1.png)

---

### 問4：キャッシュ制御の仕組み
HTTPキャッシュの2つのモデル（Expiration ModelとValidation Model）について、**仕組みと利用シーンを説明してください**。また、以下のヘッダの意味を答えてください。
```
Cache-Control: max-age=3600
Expires: Tue, 14 Dec 2021 00:00:00 JST
ETag: "abc123"
```

---
Expiration Model：レスポンスに有効期限を指定し、その期間は再リクエストせずキャッシュを利用する。Cache-Control: max-ageやExpiresヘッダで制御。静的画像やCSSなど更新頻度が低いリソースに適用。
Validation Model：キャッシュが期限切れになった際、サーバに「変更があったか」を問い合わせる。ETagやLast-Modifiedを利用し、変更がなければ304 Not Modifiedを返す。更新頻度が高いリソースに適用。
提示されたヘッダの意味は以下の通り：
Cache-Control: max-age=3600 → キャッシュ有効期限を3600秒（1時間）とする。
Expires: Tue, 14 Dec 2021 00:00:00 JST → 明示的な有効期限日時。
ETag: "abc123" → リソースのバージョン識別子。キャッシュ検証時に一致すれば変更なしと判断。 これらを組み合わせることで効率的なキャッシュ制御が可能となる。

### 問5（実演）：レスポンスJSONの分析
- 問3で取得したレスポンスJSONを分析し、**キーの命名規則（キャメルケース、スネークケースなど）と構造の特徴をまとめてください**。
- **報告内容**：
  - 実際のレスポンス例
  [
    {
        "id": "1",
        "name": "Tom",
        "age": "15",
        "comment": ""
    },
    {
        "id": "2",
        "name": "Alex",
        "age": "24",
        "comment": ""
    },
    {
        "id": "3",
        "name": "John",
        "age": "51",
        "comment": ""
    },
    {
        "id": "4",
        "name": "Steve",
        "age": "22",
        "comment": "special"
    },
    {
        "id": "5",
        "name": "James",
        "age": "19",
        "comment": ""
    }
]

  - 命名規則の評価
  キーはすべて 小文字英単語で構成されており、id・name・age・commentといったシンプルな形式。
キャメルケースやスネークケースではなく、単語一語のみのローワーケースで統一されている。
一貫性が保たれているため、可読性は高く、API利用者にとって理解しやすい。
  - 改善提案
型の適切な表現
idやageは数値型で返す方が望ましい。
命名規則の拡張
将来的に複数単語のキーが増える場合は、キャメルケースやスネークケースを採用すると一貫性が保ちやすい。
空文字の扱い改善
commentが空文字の場合はnullを返す方が意味的に明確。
スキーマ定義の明示化
APIドキュメントで「idは整数」「nameは文字列」「commentは文字列またはnull」と定義すると、利用者が安心して扱える

---

### 問6：エラー設計と詳細情報
APIでエラーが発生した場合、HTTPステータスコードだけでなく詳細情報を返すことが推奨されます。**以下の観点でエラー情報設計のポイントをまとめてください**。
- 開発者向けメッセージと利用者向けメッセージの違い
- エラー原因の分類（例：認証、権限、リソース不在）
- ドキュメントURLの付与の意義

---
開発者向けメッセージ：内部的な原因やスタックトレースなど、技術者がデバッグに利用する情報。例：「SQLクエリの構文エラー」。
利用者向けメッセージ：ユーザーが理解できる簡潔な説明。例：「入力内容が不正です」。過度に技術的な情報は不要。
エラー原因の分類：認証エラー（例：トークン不正）、権限エラー（例：管理者権限が必要）、リソース不在（例：指定IDが存在しない）、入力不備（例：必須項目欠落）など。分類することで利用者は修正方針を立てやすい。
ドキュメントURLの付与：エラー応答に関連ドキュメントへのリンクを含めることで、開発者は詳細仕様や解決方法を即座に確認できる。例えば"docs": "https://api.example.com/errors/401"のように返す。

### 問7：日付フォーマットと国際化
APIレスポンスで日付を扱う場合、RFC 3339（ISO8601）形式が推奨されます。**以下の3つのフォーマットの違いを説明し、どの形式を採用すべきか理由を述べてください**。
- `Sun, 05 Dec 2021 07:57:37 GMT`（RFC 1123）
- `2021-12-05T12:34:56+09:00`（RFC 3339）
- `Sun Dec 5 12:34:56 2021`（asctime形式）

---
RFC 1123形式：Sun, 05 Dec 2021 07:57:37 GMT。HTTPヘッダで広く利用されるが、タイムゾーンはGMT固定であり、アプリケーション側で変換が必要。
RFC 3339（ISO8601）形式：2021-12-05T12:34:56+09:00。タイムゾーンを明示でき、機械処理に適した標準形式。多言語・多地域対応に最適。
asctime形式：Sun Dec 5 12:34:56 2021。可読性はあるが曖昧で、タイムゾーン情報が欠落し、機械処理には不向き。
APIレスポンスではRFC 3339形式を採用すべきである。理由は、タイムゾーンを含めた一意性が保証され、国際的に標準化されているため、異なる地域や言語環境でも誤解なく扱えるからである。特に分散システムやグローバルサービスでは必須の形式といえる。

### 問8（実演）：Acceptヘッダの実験
- Postmanで`Accept`ヘッダを`application/json`と`text/html`に変えてSheetDB APIにリクエストし、レスポンスの違いを確認してください。
- **報告内容**：
  - それぞれのレスポンスのスクリーンショット
![スクリーンショット](images/2.png)
![スクリーンショット](images/3.png)
  - 違いの説明

---

### 問9：セキュリティ対策（XSS・CSRF）
WebAPI利用時に発生しうるXSSとCSRF攻撃について、**攻撃の仕組みと被害例を説明し、それぞれの対策を3つずつ挙げてください**。また、**Same-Origin PolicyとCORSの関係を簡潔にまとめてください**。

---
XSS（クロスサイトスクリプティング）：攻撃者が悪意あるJavaScriptを挿入し、ユーザーのブラウザで実行させる。被害例はCookie盗難や偽フォーム表示。対策は①入力値のエスケープ、②Content Security Policyの導入、③HTTPOnly属性付きCookieの利用。
CSRF（クロスサイトリクエストフォージェリ）：ユーザーが認証済み状態で攻撃者サイトを閲覧すると、意図しないリクエストが送信される。被害例は銀行振込や設定変更の不正実行。対策は①CSRFトークンの導入、②SameSite属性付きCookie、③重要操作に再認証を要求。
Same-Origin PolicyとCORS：ブラウザは同一オリジン間のみリソース共有を許可する（Same-Origin Policy）。異なるオリジン間で安全に通信するためには、サーバ側がCORSヘッダを設定し、特定のオリジンを許可する必要がある。これにより、正規のクライアントのみがAPIへアクセスできるよう制御可能となる。 総じて、入力値検証・トークン利用・適切なヘッダ設定がWebAPIの安全性を高める基本的な対策である。

### 問10：コンテンツネゴシエーション
HTTPのコンテンツネゴシエーションにおいて、**Acceptヘッダとq値（品質値）の役割を説明し、以下の例でサーバがどのメディアタイプを選択するか理由を述べてください**。
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
```

この場合、クライアントはtext/htmlとapplication/xhtml+xmlを最優先で受け入れる意思を示している。application/xmlはq=0.9でやや低い優先度、*/*はq=0.8でさらに低い。image/webpは明示的に指定されているため、同等に高い優先度を持つ。
サーバは自身が提供可能な形式の中から、最も高い優先度に合致するものを選択する。例えばHTMLページを返せる場合はtext/htmlを選択する。もしHTMLが提供できず、XMLのみ対応している場合はapplication/xmlを返す。*/*は最後のフォールバックとして利用される。
この仕組みにより、クライアントは複数の形式を提示しつつ、サーバは最適なレスポンスを返すことができ、柔軟な通信が可能となる。
